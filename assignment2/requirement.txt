https://www.cs.sfu.ca/~mitchell/cmpt-225/2020-Spring/assigns/A2-search-trees/A2-search-trees.html

CMPT 225 Assignment 2: Search Tree Exercises

Due: 8:00 pm, Friday March 6.
This document is Copyright Â© David Mitchell, 2020.
(So what? It means that if you post or otherwise distribute copies of this assignment, or substantial parts of it, in any more-or-less public place, without my permission, you will be in violation of the SFU Student Academic Integrity Policy.)

This assignment consists of small exercises in coding search tree operations. It involves making changes to the BST and AVL Tree implementations provided by the textbook author.

BST function count_leaves()
Modify the provided BST implementation (in BinarySearchTree.h) by adding a function int count_leaves() that returns the number of leaves. (A tree with few leaves is necessarily "straggely"; although one with many leaves is not necessarily bushy.) The counting should be done using recursion on the tree. (For an example, start by looking at the printTree function, which traverses the tree. You can modify this function to recursively count the number of leaves in each sub-tree.) In the implementation, you should follow the example provided by the author's implemenations of insert(x) and remove(x), with a public function that simply makes call to a recursive private function that does the work.
BST function countDeep(int k)
Modify the BST implementation by adding a function int countDeep(int k), that returns the number of nodes in the tree at depth greater than k. It should perform this computation recursively, and once again you the public function should simply make a call to a private recursive function that does the work.
Modified AVL Tree insert and remove
The implementations of insert and remove in AvlTree.h are recursive, and every recursive call ends by performing a balance check at a node. This means that, for each insert or remove operation, a balance check is performed on every node on a path from the root to a leaf. As we know, sometimes this is required, but often most or all of those checks are not needed. The task is to modify insert(x), remove(x) and balance(t) so no nodes are checked for balance that do not need to be. There are two obvious ways to do this:
Re-write insert and remove to be non-recursive. During the search up the path toward the root, check for the conditions under which balance of the remainder is ensured. This is not the recommended method.
Change the return types of insert, remove and balance, so they return information about whether more balance checking is needed. For example, in the case of insert, we know that after one node is rebalanced, no other node will need rebalancing. Suppose we let balance(t) return true if it rebalanced node t, and false otherwise. Then, the (recursive) insert can also return a Boolean value, informing the calls on ancestor nodes (nodes further up the tree) that no checking for balance will be required there. A similar method can be used for remove, although it is possible a different version of balance(t) will be needed. There are several possible ways to work out the details -- some much simpler than others -- and figuring out more than one way is a good exercise.
Start this part with this version of AVLTree.h, which has balance modified to report on the node that it is working on. This provides output which can help verify whether or not balance is being called on nodes where it is not needed. Leave this print line in your final version(s) of balance.
Submission

You should submit a .zip file containing the following files:
BinarySearchTree1.h (Solution to the countLeaves() question)
BinarySearchTree2.h (Solution to the countDeep(k) question)
AvlTreeB.h (Solution to the balance question)
dsexceptions.h (as provided by the author)
TestLeaves.cpp (Test program for countLeaves)
TestDeep.cpp (Test program for countDeep)
TestBalance.cpp (Test program demonstrating balance solution)
Makefile ("make all" should compile all the test programs; "make clean", "make testLeaves", "make testDeep" and "make testBalance", should all do the obvious things.)
This assignment will be graded out of 28: 4 marks each for countLeaves() and countDeep(); 6 marks for correct fixing of balance(); 2 marks for comments in your AVL tree code that clearly explain your method; 3 marks for each test program; 3 marks for the make file;

To get full marks for your modified BinarySearchTree and AVLTree classes, test programs we write to use the classes must complile and run correctly with them. To obtain full marks for the test programs, they must: compile and run correctly with our implementations of the classes; perform meaningful demonstrations of correctness of the classes; produce terminal output that explains what tests they are doing and shows the results are as intended.

Marks are assigned only for code that compiles and runs on the CSIL Linux machines. A "complete" solution that cannot be compiled and run is worth zero marks. However, if you cannot complete all parts of the assignment, you can get partial marks for parts that are working. So, it is important to have working code at all times, even if that code does not do everytying it should. (That way, you won't suddenly realize that time is up and you don't have anything to submit because of bugs you can't find.) It follows that you should develop your solutions according to a process that ensures you get part marks if something goes wrong or you run out of time.

